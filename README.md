新时代，新技术，需要新底座。编程语言作为应用软件开发的底座，需要融入新的场景例如万物互联，以及新的技术例如 AI。

仓颉面向全场景，集成了现代语言特性，进行了全方位的编译优化和运行时实现，拥有开箱即用的 IDE 工具链支持。具体特性如下：

- 高效编程：

  - 多范式，支持函数式、命令式和面向对象，函数式的核心是纯函数和高阶函数，纯函数就像数学中的函数表达式，相同的输入总是产出相同的输出且不产生任何副作用，副作用值的是对外部环境的修改。高阶函数是一种将函数作为参数或者将函数作为返回结果的函数，可以简单把它理解为处理函数的函数，所以称它为高阶函数。

  - 值类型，直接存储和复制数据本身，不存在数据的引用传递，使程序更可靠，可预测，尤其在并发安全的场景下

  - 代数数据类型(ADT Algebraic Data Type)，代数是数学中的一个概念，可以把它理解为抽象并且加强过的数字，举个例子`a + b`, 最简单的 a,b 就是数字，代数的场景下，a,b 可以是符号和表达式。代数常见的有“组合”和“替代”，在代数数据类型下，就是“积类型”和”和类型“。
    ”组合“以及”积类型“值的是组合不同的基本类型构成一个新的复合类型，”替代“以及”和类型“指的是多态，一个类型可以被多种类型替代，例如枚举类型`enum`,一个枚举类型是多种类型的集合（”和“）。使用 ADT 我们可以灵活的构建复杂的数据结构。

  - 模式匹配，就像正则表达式匹配对应的字符串，模式匹配可以匹配数据结构的类型和值。它提供了一种直观并且类型安全的方式来处理数据结构。

  - 类型推断，如果在上下文中可以明确的推断出具体的类型，则可以利用类型推断来省去类型标注的工作，减少冗余代码，提升开发效率。

  - 类型扩展，在不破坏原有类型的封装性的同时，为原有类型添加额外的功能，例如添加函数，属性，操作符重载，实现接口

  - 语法糖，就像甜甜的糖能够点缀你的生活，语法糖通过便利简洁的语法，可以提升开发效率和代码的可读性。

  - 宏，定义可重复使用的代码片段，在编译时，通过”宏展开“，会自动将”宏“替换为指定的代码片段。”宏“的本意是宏大，你可以简单理解为一段宏大复杂的代码，宏的作用就是定义这段代码。正是因为宏可以在编译前对代码进行预处理，因此它可以隐藏实现细节，简化编程任务，让程序开发更灵活。

- 安全可靠：

  - 静态类型系统，通过编译时的类型检查，实现编码即安全

  - 自动内存管理，自动 GC，自动识别和回收不再需要使用的对象

  - 空引用安全，仓颉实现了空引用安全，消除了代码空引用的危险，仓颉的引用类型永远是非空的，没有`null`值，使用`Option<T>`可选类型

  - 完善的运行时检查，在运行时会进行溢出检查和数组越界等检查，在进行整数运算时如果结果溢出或者数组越界访问时，会抛出运行时异常。

  - 代码混淆，混淆是一种代码资产保护的技术，可以简单理解为对代码进行”加密“， 可以防止攻击者采用逆向工程对程序进行攻击，获取程序的符号名，路径信息，或者行号信息等敏感的信息。

  - 代码扫描和消毒，通过代码扫描工具，可以发现潜在的漏洞和代码质量问题，通过消毒工具，可以清理代码中的各类安全威胁，例如病毒和恶意代码等。

- 轻松并发：

  - 并发和异步编程能够提升处理器利用效率，提升响应速度。

  - 极其轻量的用户态线程（原生协程），由运行时管理，不依赖操作系统，拥有独立的执行上下文但共享内存，占用资源小，线程的创建，切换的开销小。

  - 为了解决数据竞争的问题，仓颉还引入了并发对象库，并发对象的方法都是线程安全的，对于一些核心库，仓颉还提供了无锁和细粒度锁的算法实现，进一步减少了线程的阻塞，提升并发度。

- 卓越性能：

  - 编译器全栈优化

    - 编译器前端基于 CHIR (Cangjie HighLevel Intermediate Representation) 生成高质量的中间代码，例如：

      - 语义感知的循环优化：语义感知指的是不仅关注代码的表面，还能了解代码实际的逻辑含义，能够更深入的对代码进行优化，例如基于语义感知，编译器可以识别循环中的不变变量，将它们从循环中移出。循环是代码中的常见结构，包含重复执行的代码块，对循环进行优化可以显著提升程序的性能。循环优化的常见方式：

        - 循环展开（Loop Unrolling）：将循环体中的代码复制多次，从而减少总的循环次数。
        - 循环提升（Loop Hoisting）：将循环中与迭代次数无关的计算移到循环外部，这些计算只需执行一次，无需在每次迭代时重复执行。
        - 循环融合（Loop Fusion）：将多个循环拥有相同的迭代变量时，可以进行合并，例如循环 A 和循环 B，都是从 1 到 10 的循环，这个时候就可以进行合并，循环次数从 10 + 10 次减少到了 10 次 。
        - 循环剥离（Loop Peeling）：在循环中有的代码逻辑只在特定的迭代次数下执行，例如`i=0 || i=length-1`首次和最后一次，这些代码逻辑无需被重复执行和判断，这个时候可以将他们剥离至循环体外，来减少循环的开销 。
        - 强度削减 (Strength Reduction)：使用计算成本低的等效操作代替计算成本高的，例如将乘法替换为加法或者位移操作，将除法替换为乘法。
        - 冗余消除：常见的冗余有重复计算冗余，死代码冗余，类型转换冗余，可以简单理解为进行无效劳动的代码。
        - 软件流水线（Software Pipelining）：重新组织循环的代码，使其像硬件流水线一样，多个迭代可以部分并行执行。想象现实的汽车工厂，会有多条流水线并行执行，例如发动机流水线，安装座椅流水线，安装轮胎流水线，这些流水线并行执行，能有效地提升效率。
        - 向量化（Vectorization）：在计算机科学中，向量是一组数据项的组合，这些数据项可以被处理器的 SIMD（Single Instructino, Multiple Data）指令同时操作。SIMD 指令可以在单个 CPU 周期内对多个数据执行相同的操作。举个形象的例子来说明什么是向量操作，假设你是餐厅的服务员，需要给客人拿饮料，当你什么工具都没有的时候，你一次性只能拿已被饮料，这就是标量操作，现在，你有了一个可以盛放好几杯饮料的托盘，一次性可以拿好几杯饮料，这就是向量操作，这里面的每一杯饮料代表一个数据元素，托盘代表向量寄存器，你的服务就代表 SIMD 指令。
        - 循环倾斜（Loop Tiling）：程序在执行过程中对数据的访问倾向于集中在一小部分数据上，而不是随机或均匀分布，这被称为数据的局部性原理，现代系统充分使用数据的局部性原来来设计缓存，提升缓存的命中率。缓存的基本单位是缓存行，因为数据的局部性原理，保存在同一缓存行中的数据会被连续访问。利用这一点，可以将一个大循环切分为小循环，因为在大循环中访问数据需要跨越多个缓存行，缓存行会被不断地重新加载和访问，缓存的命中率低，在小的循环中，数据在同一缓存行中的概率增加，可以有效减少缓存行的无效加载。
        - 条件编译：去除循环中不会执行的分支和条件检查。

      - 语义感知的后端协同优化，后端优化的目标是将前端编译优化生成的中间代码(CHIR)生成高质量的机器代码。后端的编译优化方式主要有：

        - SLP(Scalar Replacement in Aggregates) 向量化：将多个标量变量替换为一个聚合数据结构，利用向量化同时处理聚合结构中的多个元素，提高数据的并行处理能力。
        - Intrinsic(内置函数) 优化：编译器的内置函数，提供了对特定硬件的直接操控，确保关键代码以最高效的方式执行。
        - InlineCache(内联缓存，简称 IC)：在程序执行的过程中，访问对象属性或者调用方法时，需要进行类型检查和查找，IC 的作用就是利用缓存的原理，将访问过的对象属性或者方法缓存起来，来减少查找带来的开销。
        - 过程间指针优化：通过对多个过程或函数的指针进行引用分析，我们可以实现以下几个优化目标：
          - 消除指针别名：将指向同一对象的指针进行合并优化。
          - 减少内存占用：优化数据结构的布局，减少由于指针操作引起的内存浪费。
          - 提高数据的局部性：分析指针的引用，可以优化数据访问模式，提高缓存的命中效率。
        - Barrier(内存屏障) 优化：在并行程序中，往往需要进行线程同步，即确保在所有参与的线程都到达屏障点(Barrier)之后再执行接下来的代码逻辑。

  - 运行时优化

    - 轻量锁：重量级锁依赖操作系统内核，涉及线程阻塞和上下文切换，性能开销大。轻量锁基于 CAS(Compare-And-Swap)，采用不阻塞线程的自旋等待的方式，来避免线程切换带来的开销。
    - 分布式标记：标记和回收处在分布式环境中的数据和对象。
    - 并发 Tracing 优化：通过对多线程进行监控和记录，分析线程的执行路径，锁等待事件和上下文切换，来优化线程的调度和同步机制，减少锁的竞争和死锁的风险。
    - 原生的轻量化设计：对运行时进行模块化分层设计，定义公共对象模型，减少多个能力间的冗余对象设计，精简运行时体积。
    - 按需加载：通过包的按需加载，减少应用启动时的资源消耗。

除此之外，仓颉还支持面向应用开发的一系列工具链，包括语言服务（高亮，联想）、调试（跨语言调试、线程级可视化调试）、静态检查、性能分析、包管理、文档生成、Mock 工具、测试框架、覆盖率工具（帮助开发者了解测试用例覆盖了代码的哪些部分）、Fuzz 工具（生成大量的随机测试数据）以及智能辅助编程工具。

[下一篇：高效编程](./white-paper/2-efficient-programming.md)
