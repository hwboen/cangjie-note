# 轻松并发

## 轻量化线程模型

用户态线程，原生协程，拥有独立的执行上下文，并共享内存。用户态线程有有栈和无栈两种实现方式，栈后进先出，天然适应函数的调用链，栈的基本单位是栈帧，栈帧用于保存每个函数的执行状态，包含局部变量、执行位置、返回地址（即该函数执行完后的下一步执行位置）。

- 有栈：仓颉采用有栈的用户态线程模型，每个线程拥有独立的栈来保存当前线程的执行状态。
- 无栈：采用状态机来代替栈，以下用一个简单的例子来说明什么是状态机。

  ```
  class Example:
    def __init__(self):
      self.state = 0

    async def run(self):
      if (self.state === 0):
        print('Step 1')
        // 协程被挂起，保存状态机状态
        await async_operation_1()
        self.state = 1

      if self.state === 1:
        print('Step 2')
        await async_operation_2()
        self.state = 2

      if self.state === 2:
        print('Step 3')
        await async_operation_3()
        self.state = 3
  ```

  无栈模式下，通过标记异步操作点，然后编译器手动插入状态机代码，通过状态机来管理当前线程的执行状态。因此需要引入特殊的语法用来标记异步操作点，最常见的就是`async/await`。`async`标记的函数会转换为一个状态机，`await`标记的表达式为这个状态机的状态转换点。由于包含`await`的函数必须标记`async`, 因此会存在“函数染色”的问题，即异步函数调用链中的每个函数都需要显示地标记为`async`。仓颉线程采用有栈模式，拥有独立的执行上下文，无需担心“函数染色”的问题。

  用户态线程管理在用户空间，无需切换内核态，操作系统从用户态切换到内核态是一个消耗资源且耗时的操作，涉及到上下文的切换，权限级别的切换，异常和中断处理等。

  仓颉线程实现完全在用户空间进行，不依赖操作系统的线程管理，从根本上减少了线程创建、销毁、调度的开销。传统内核态线程的创建一般为百微妙，而仓颉线程的创建耗时为 700ns。此外，一个仓颉线程仅占 8kb 的内存，开发者可以在一个程序中创建十万级数量的线程，适应于 I/O 密集型和高并发的使用场景。

## 无锁并发对象

一般语言通过互斥锁来解决多线程的数据竞争问题。操作系统提供的互斥锁是重量级的，因为它们涉及到内核调度和管理，可在用户态借助原子操作（常见的例如 CAS）来实现轻量级的互斥锁。

仓颉并发对象设计采用细粒度并发算法，并且具有并发原子性，可以简单理解为调用并发对象的方法不会被其他线程打断。以下是仓颉提供的多线程共享并发对象：

- 原子整数类型：AtomicInt8、AtomicInt16、AtomicInt32、AtomicInt64、AtomicUInt8、AtomicUInt16、AtomicUInt32、AtomicUInt64
- 原子布尔类型：AtomicBool
- 原子引用类型：AtomicReference、AtomicOptionReference
- 并发哈希表：ConcurrentHashMap：线程安全的哈希表实现，使用细粒度并发算法实现。
- 并发队列：
  - BlockingQueue：带阻塞机制的有容量上限的并发队列，当队列为空时，尝试从队列中获取元素的线程会被阻塞，当队列满时，尝试向队列添加的线程会被阻塞，常用于生产-消费的场景。
  - ArrayBlockingQueue：基于数组实现，固定大小，可以减少运行时的内存分配和垃圾回收。
  - NonBlockingQueue：在添加时，如果已满，不会导致线程阻塞，多个线程可以并发的进行队列的操作，不会出现数据冲突或者死锁的问题。相比 BlockingQueue 能够支持更多的并发，BlockingQueue 为了保护线程安全，同一类型的操作最终只允许一个线程。

[上一篇： 安全可靠](./3-safe.md)

[下一篇： 卓越性能](./5-outstanding-performance.md)
