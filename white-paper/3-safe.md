# 安全可靠

仓颉通过静态类型系统，动静态检查，自动内存管理，以及工具链来提升程序的安全性。

## 静态类型和垃圾收集

在仓颉中，所有变量和表达式的类型都是在编译期决定的，并且在程序运行过程中不会改变。静态类型能在编译期尽早发现程序的错误，并为编译优化提供更多的信息。

仓颉采用 tracing GC 技术，通过在运行时跟踪对象之间的引用关系，来识别活动对象和垃圾对象。常见的垃圾收集技术有：

- tracing GC：定期遍历所有从根对象（如全局变量）可达的对象，如果一个对象不可达，则是垃圾对象。优点是开销小，不需要额外维护引用计数器，可以解决循环引用的问题，缺点是实现复杂，需要解决 STW（Stop-The-World） 垃圾回收时程序暂停的问题。

- 引用计数 RC (reference counting)：为每个对象维护一个引用计数器，当有新的引用指向该对象，计数器增加，当引用离开或删除时，计数器减少，当引用次数为 0 时，意味着该对象可以被垃圾回收。它的优点是简单容易实现，可以实时回收，不用等待垃圾回收的周期运行。缺点是需要额外的空间来维护引用计数器，并且可能存在循环引用，导致计数器一直不为 0，造成内存泄漏，而且频繁更新引用计数可能会影响程序性能。

## 空引用安全

空引用被称为价值十亿美元的错误，空引用安全旨在消除空引用危险。仓颉实现了空引用安全，在仓颉中不存在 null 值，引用类型永远都是非空的。

仓颉通过可选类型`Option<T>`来提供空值语义，`Option<T>`是一种 enum 类型，表示有值(`Some(v)`)或空值(`None`)两种状态。

```
enum Option<T> {
    Some(T) | None
}
```

`Option<T>`类型的表达式 e,必须通过模式匹配其值为`Some(v)`时，才能取得 v 值，不可能直接对`None`做解引用，因为从根本上避免了空引用异常。仓颉还提供了`?T`语法糖来代替`Option<T>`。

```
  let a: ?Int = None
  a?.toString()
```

## 值类型

值类型传递即复刻，保存数据自身，而非引用。最典型的并发安全问题就是在不同线程中传递了同一个可变对象，如果这个对象具有值类型的语义，那么每个线程都将拥有这个对象的完整复刻，对这个对象的访问将彼此独立，从而保证线程安全。

仓颉除了 Int 类型外，struct 也具有值语义，可以构建属于自己的值类型。

## 不可变优先原则

不可变对象只读不写，无副作用，天然线程安全。在仓颉中，let 定义的变量就是不可变变量。

在仓颉中，所有函数形参都是不可变的，无法对形参赋值，也无法修改值类型的成员。

模式匹配引入的新变量是不可变的，也无法修改值类型的成员。

当一个可变变量被闭包捕获时，该闭包不允许逃逸

```
func f() {
  let a = 1
  var b = 2
  func g() {
    print(b)
  }
  g
}
```

## 默认封闭

仓颉采取默认封闭的设计原则，类默认不可被继承，方法也默认不可被覆盖。因为这样可以避免引入非必要的继承抽象，增加程序的复杂度。开发者主动考虑是否需要子类的能力，避免继承的滥用。

类默认不可被继承，必须显示使用`open`、`abstract`修饰，类的成员函数也默认不可覆盖，需要显示使用`open`修饰，哪怕 class 是 open 的。

## try-with-resources

仓颉提供 try-with-resources 来自动管理非内存资源，catch 和 finally 都是可选的,可在 try 中同时申请多个资源，仓颉会在资源发生异常或者代码执行结束后，自动释放资源。简而言之，开发者无需关心各种情况下的资源释放问题。不过申请的资源类型需要实现`Resource`接口，并且实现`isClosed`和`close`函数。

## 动态安全检查

仓颉编译器优化后将运行时检查控制在一个较小的水平。

仓颉中的整数计算溢出默认会抛出运行时异常，不希望抛出异常，也可以通过关键字`OverflowWrapping`手动指定传统的`wrapping`策略。
对于无法在编译期检查的数组越界问题，仓颉也会在运行时进行检查。

## 混淆

仓颉为了防止开发者逆向攻击软件，提供了多种混淆技术来保护代码资产。攻击者可通过逆向工程技术，获取程序的符号名，特征字符串和特征常数，以及控制流信息。仓颉支持以下几种混淆技术：

- 外形混淆：函数名和变量被随机字符串代替，路径名被 SOURCE 代替，行号修改为 0。
- 数据混淆：对明文字符串进行加密保护，在程序初始化时再解密字符串。对于程序中使用的常量，仓颉编译器会将它转化为等价的，更加难以理解的代码片段。
- 控制流混淆：在不影响程序正常执行的前提下，自动打乱，重排基本块之间的跳转关系，提升理解程序流程的难度。
