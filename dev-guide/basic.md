# 基本概念

## 标识符号

- 普通标识符：`XID_START` 开头 后接任意长度的 `XID_CONTINUE` 或者 `_`开头后接任意长度的 `XID_CONTINUE`。XID 是 XML Identifier 的缩写，因此可以直接理解为符合 XML 的命名规范。仓颉的`XID_START`和`XID_CONTINUE`又遵循 Unicode 标准。仓颉的标识符最终都会被 转化为 NFC(Normalization Form)，因此在 Unicode 中两个看起来相同的字符，一个可能是预组合字符，另一个可能是组合字符，它们看起来是一样的，但它们的 Unicode 字符是不同的，NFC 可以解决这种问题，使得字符所见即所得，表面相同的字符就是相同的。
- 原始标识符：在普通字符或者关键字上加上反引号，就可以作为标识符来使用了。

## 程序结构

仓颉源码文件拓展名为`.cj`，通过添加`main`函数，在编译后会生成特定格式的二进制代码。`main`不需要使用`func`关键词修饰，返回类型可以是整数类型或者 Unit，通过 main 的形参`Array[String]`获取命令行启动参数。

在仓颉的顶层作用域中，即源文件中最外层的作用域，可以定义自定义类型（enum, interface, class, struct），变量和函数。非顶层作用域，例如函数作用域中只能定义局部变量和局部函数。在自定义类型中定义的变量和函数称为成员变量和成员函数。

enum 和 interface 只支持定义成员函数，不支持定义成员变量。

### 变量

定义变量的形式

```
修饰符 变量名：变量类型 = 初始值
```

修饰符有：

- 可变性修饰符：var 和 let，分别为可变变量和不可变变量，当 let 指向一个引用类型时，该变量可以修改引用类型中的可见变量，如果 let 指向一个值类型，例如 struct 定义的值类型，则无法修改该值类型的成员变量，因为值类型中存储的就是数据本身，不存在引用语义。
- 可见性修饰符：private, public, protected
- 静态性修饰符：static

定义全局变量和静态成员变量时，必须指定初始值，定义局部变量和实例成员变量时，可以省略初始值，在必须在该变量被引用前完成初始化。

- 值类型和引用类型

  仓颉在编译时会将标识符转化为数据实体或者存储空间的引用。程序运行时，只有指令流转和数据转换，标识符在运行时不复存在，值类型的标识符，在编译时转化为数据实体，引用类型的标识符转化为存储空间的引用。

  值类型变量直接获取数据本身，引用类型变量需要通过引用指针进行数据的索引。也就是说值类型变量绑定的数据和存储空间是独占的，而引用类型的存储空间是共享的。对于 let 修饰的引用类型变量，只是代表引用关系不可变更。

### 作用域

作用域定义了变量和函数的可见性范围，将名字和程序元素（例如函数）的绑定关系限定在一定范围中。源文件中不被`{}`包含的代码处于顶层作用域，即最外层的作用域。作用域可以嵌套，内层作用域可以访问外层作用域，相反则不行，并且内存作用域优先级高于外层作用域，可以覆盖外层作用域中的绑定关系。

在顶层作用域中可以定义变量，函数以及自定义类型。非顶层作用域中只能定义变量和函数。

## 表达式

传统的算术表达式由一个或多个操作数和零个或多个操作符组成，它代表一个计算过程，对于没有操作符只有操作数的表达式，计算结果就是操作数本身。

在仓颉中，任何可求值的程序元素都是表达式，除了传统的算术表达式，还有条件表达式，循环表达式和 try 表达式，它们都可被求值。

程序的执行流程只会涉及三种基本结构：顺序、分支、循环。其中分支和循环是通过某些指令控制当前顺序执行流产生跳转而得到的。

条件表达式有 if 表达式和 if-let 两种，值为每个分支的返回类型，循环表达式有 for-in、while、do-while、while-let，表达式返回的类型为 Unit, 值为`()`。部分控制转移表达式有 break、continue。

不含 else 分支的 if 表达式的类型为 Unit,值为`()`。

`do-while`表达式先执行循环体，再执行条件表达式。

- `for-in`表达式：遍历实现了`Iterable<T>`接口的类型实例，即遍历的对象需要具体迭代器能力。仓颉内置的数组和区间已经拓展了该接口。

  ```
    for (迭代变量 in 实现了`Iterable<T>`接口的序列 where 条件表达式) {
      循环体
    }
  ```

  迭代变量遵循仓颉默认不可变的设计原则，是是不可变变量。当不需要使用迭代变量的时候，可以使用`_`通配符代替。

  遍历区间

  ```
    for (i in 1..=100) {
      print(i)
    }
  ```

  遍历元组数组，迭代变量可以对元组进行解耦赋值。

  ```
    let arr = [(1,2), (3,4), (5,6)]
      for ((a, b) in arr) {
      println(a)
      println(b)
    }
  ```

- break，continue 表达式的类型都是 Nothing,break 结束整个循环结构，continue 结束这一轮循环，跳转至下一轮循环。

## 函数：func 关键字修饰 + 函数名 + 参数列表 + 返回类型 + 函数体

```
  func add(a: Int, b: Int) {
    a + b
  }
```

[下一篇：基本数据类型](./primitive-types.md)
