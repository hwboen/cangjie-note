# 基本数据类型

## 整数类型

分为有符号整数和无符号整数，它们的区别就是首位是否用来表示正负。有符号整数有 Int8, Int16, Int32, Int64 和平台相关的 IntNative，无符号整数 UInt8、UInt16、UInt32、UInt64 和 UIntNative。整数字面量没有类型上下文时，默认 Int64，在 Int64 合适的情况下，首选 Int64，因为可以避免不必要的类型转换。

整数类型字面量有四种进制表示形式：二进制（0b 或 0B 前缀）,八进制（0o 或 0O 前缀）,十进制（没有前缀），十六进制（0x 或 0X 前缀）。所有进制表示形式都支持`_`分隔符，例如`0b000_1111`。如果字面量超出上下文类型的表示范围，将会编译报错，编译时无法确定时，会抛出对应的运行时错误。

整数字面量还支持后缀来提供上下文类型信息，例如`let a = 123i8`，此时 a 的类型为 Int8，`let b = 123u8`，b 的类型为 UInt8。

还支持字符字节字面量，以方便使用 ASCII 码来表示 UInt8 类型的值：

```
let a = b`x` // b 是 byte 字节的缩写
let b = b`\u{78}`
let c = b`\n`
```

取模运算`%`运算只支持整数类型，幂运算`**`的左操作数只能为 Int64 或 Float64，当左操作数为 Int64 时，右操作数只能为 UInt64，表达式的类型为 Int64。当左操作数为 Float64 时，右操作数只能为 Int64 或 Float64，表达式的类型为 Float64。

自增自减操作符`--`或者`++`只能作为一元后缀符使用。也就是只支持`a++`，不支持`++a`。

支持赋值操作符`+=`，`-=`等等。

## 浮点数类型

仓颉支持 Float16（半精度），Float32（单精度），Float64（双精度），为 IEEE 754 中的标准。

单精度的浮点数在计算机中采用 32 个字节来存储，其中 1 位表示正负，8 位表示指数，剩余的 23 位表示尾数位。拿十进制小数 9.5 举例子，首先我们
9 和 0.5 分别用二进制表示，9 的二进制为 1001，0.5 转化为二进制为 0.1，因此 9.5 的二进制表示为 1001.1，将它转化为科学计数法 `1.0011 * 2^3`，指数为 3，为了尽可能的扩大指数可表示的范围，指数需要加上偏移量（`2^7` - 1 = 127），因此实际存储指数的 8 位都是正整数，省去了符号位，因此最终的指数为 `3 + 127 = 130`，尾数部分为 0011 后面按照 23 位用 0 补齐，得到 001100000000000000000，最终 9.5 在存储的二进制表示为 `0 10000010 001100000000000000000`。

双精度浮点数一共 64 位，一位符号位，11 位指数位，52 位尾数，尾数大致位单精度的两倍，因此它们被称为单双精度。而半精度一共 16 位，1 位符号位，5 位指数位，10 位尾数位，精度大致为单精度浮点数的一半，因此被称为半精度。

更通俗一点讲，Float16 半精度精确到小数点后 3 位，Float32 单精度精确到小数点后 6 位，Float64 双精度精确到小数点后 15 位。因此常规计算采用单精度即可，占用内存小，如果需要精确度很高的就使用双精度。

浮点类型字面量支持十进制和十六进制两种形式：

- 采用十进制时，需包含整数或小数部分，没有小数部分时，必须包含指数部分，指数用 e 或 E 表示，例如`let a = 2e3`，a 为 Float64 类型。
- 采用十六进制时，除了整数和小数部分，必须包含指数部分，用 p 或 P 表示，例如`let a = 0x1p2`。

使用十进制浮点数字面量时，可以添加后缀例如`f16`，`f32`，`f64`，例如`let a = 2e3f16`，a 的类型位 Float16。

浮点数不支持自增和自减操作。

## 布尔类型

Bool，仅有 true 和 false 两个字面量。

支持 `&&=` 和 `||=` 复合赋值运算。例如 `a &&= b` 相当于 `a = a && b`，就像 `a += 2`等同于 `a = a + 2`。

## 字符类型

字符类型在仓颉中使用 Rune 表示，Rune 的中文意思是古代的字符，可以表示所有的 Unicode 字符。

字符类型字面量支持三种表示形式：单个字符，转义字符，通用字符。

```
let a: Rune = r`a`
let a2: Rune = r`\'`
let a3: Rune = r`\u{4f60}`
```

在仓颉中字符之间的比较是根据 Unicode 值来的，Rune 和 UInt32 之间可以相互转换。

## 字符串类型

字符串类型用 String 表示，由多个 Unicode 字符表示。在仓颉中，不区分单引号和双引号，它们的作用是相同的，它有三种字面量表示形式：

- 单行字面量：使用一对单引号或双引号包裹，支持转义字符
  ```
    let a = "a\n"
  ```
- 多行字面量：使用三队单引号或双引号包裹，支持转义字符
  ```
    let a = """
      第一行\n
      第二行
    """
  ```
- 多行原始字面量：使用`#`号对 + 单双引号，不支持转义字符规则，转义字符将被当做普通字符
  ```
    let s = #"
      第一行\n
    "#
  ```

表示 ASCII 的单字符字符串可以自动转换为 Byte（UInt8）

```
let a: Byte = "a"
```

单字符的字符串可以自动转化为 Rune

```
let a: Rune = "你"
```

字符串支持插值语法`let a = "${b}"`，插值语法不适用于多行原始字符串紫字面量。插值表达式中可以有多个表达式，最后一个表达式的值作为返回值。

## 元组

将多个类型组合在一起，元组一旦定义即不可修改，包括长度和变量。`(T1,T2,T2..TN)`，T 可以是任意类型，中间使用,隔开。

元组类型字面量 `(e1,e2,eN)` e 是表达式。通过 index 下标访问。

支持对 Tuple 类型进行解构赋值。

```
  let t1 = (1,2,3)
  let (a,b,_) = t1
```

可以为元组类型加上参数名，要么全都有参数名，要么都没有，不允许部分命名。

```
let t1: (name: String, age: Int) = ("boen",2)
```

## 数组

- `Array<T>` 单一元素序列，引用类型，长度固定，无法修改。

  可以通过数组字面量床架数组：

  ```
  let arr: Array<String> = []
  let arr2 = [1,2,3,4]
  ```

  也可以通过构造函数创建：

  ```
  let a = Array<String>() // 空数组
  let a2 = Array<String>(3) // 长度为3的数组
  let a3 = Array<Int>(3, 1) // 长度为3，初始值为1
  let a4 = Array<Int>(3, {i => i + 1}) // 通过Lambda来初始化
  ```

  可以使用 Range 获取数组中的某一段数据：

  ```
  let a = [1,2,3,4]
  let b = a[0..2] // 1,2
  let b2 = a[2..3] // 3
  let b3 = a[..3] // 1,2,3
  let b4 = a[1..] // 2,3,4
  ```

- 数值类型数组`VArray<T, $N>`，相比引用类型数组，拥有了值类型的特点，元素不可变化，赋值即复制。字面量和访问方式和普通数组一样。支持与 C 语言互操作。

```
let a = VArray<Int, $3>(repeat: 0)
let a2 = VArray<Int, $3>({i => i + 1})
```

## 区间 `Range<T>`

`Range<T>`固定步长的有序序列，包含 start, end, step 三个元素，step 默认为 1，不能为 0。

```
Range<T>(start: T, endT, step: Int64, hasStart, hasEnd, isClosed)
```

支持左闭右开，左闭右闭的字母量语法，带`=`即代表闭合。

```
let r = 1..3:1 // 1,2, 步长为1
let r2 = 1..=3:1 // 1,2,3，步长为1
```

定义区间类型的时候，根据步长，会存在为空的区间，但不会报错。

## Unit

只关心副作用不关心值的表达式的类型，例如 print 函数，赋值，复合赋值，自增自减，循环表达式。

Unit 类型的值只有`()`，并且只支持判等，赋值等操作。

```
let a = ()
print(() == ()) // true
```

## Nothing

该类型没有任何值，Nothing 类型是所有类型的子类型。Nothing 在仓颉中的作用主要是控制流程。break,continue,return,throw 表达式的类型都是 Nothing 类型，程序在执行到这些表达式后，其相同作用域之后的代码不会执行。目前编译器还不允许显示的使用 Nothing 类型。

[上一篇：基本概念](./basic.md)

[下一票：函数](./func.md)
